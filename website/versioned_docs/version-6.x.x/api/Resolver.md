---
id: version-6.x.x-Resolver
title: Resolver
custom_edit_url: https://github.com/graphql-compose/graphql-compose/blob/master/src/Resolver.d.ts
original_id: Resolver
---

<!-- 
ðŸ›‘ðŸ›‘ðŸ›‘
DO NOT EDIT THIS FILE!
IT WAS AUTOGENERATED FROM d.ts FILE
ðŸ›‘ðŸ›‘ðŸ›‘
If you want to make changes in this file, please do it via
https://github.com/graphql-compose/graphql-compose/blob/master/src/Resolver.d.ts
-->

The most interesting class in `graphql-compose`. The main goal of `Resolver` is to keep available resolve methods for Type and use them for building relation with other types.

## Properties

### schemaComposer

```js
schemaComposer: SchemaComposer<TContext>;
```

### type

```js
type: ComposeOutputType<TReturn, TContext>;
```

### args

```js
args: ComposeFieldConfigArgumentMap<any>;
```

### resolve

```js
resolve: (
  resolveParams: Partial<ResolveParams<TSource, TContext, TArgs>>
) => Promise<any> | any;
```

### name

```js
name: string;
```

### displayName

```js
displayName: string | void;
```

### kind

```js
kind: ResolverKinds | void;
```

### description

```js
description: string | void;
```

### parent

```js
parent: Resolver<TSource, TContext, any> | void;
```

## Output type methods

### getType()

```js
getType(): GraphQLOutputType
```

### getTypeComposer()

```js
getTypeComposer(): ObjectTypeComposer<TSource, TContext>
```

### setType()

```js
setType<TNewReturn>(
  gqType: ComposeOutputType<TNewReturn, TContext>
): Resolver<TSource, TContext, TArgs, TNewReturn>
```

## Args methods

### hasArg()

```js
hasArg(
  argName: string
): boolean
```

### getArg()

```js
getArg(
  argName: string
): ComposeArgumentConfig
```

### getArgConfig()

```js
getArgConfig(
  argName: string
): GraphQLArgumentConfig
```

### getArgType()

```js
getArgType(
  argName: string
): GraphQLInputType
```

### getArgTC()

```js
getArgTC(
  argName: string
): InputTypeComposer<TContext>
```

### getArgs()

```js
getArgs(): ComposeFieldConfigArgumentMap<TArgs>
```

### getArgNames()

```js
getArgNames(): string[]
```

### setArgs()

```js
setArgs<TNewArgs>(
  args: ComposeFieldConfigArgumentMap<TNewArgs>
): Resolver<TSource, TContext, TNewArgs>
```

### setArg()

```js
setArg(
  argName: string,
  argConfig: ComposeArgumentConfig
): this
```

### extendArg()

```js
extendArg(
  argName: string,
  partialArgConfig: Partial<ComposeArgumentConfigAsObject>
): this
```

### addArgs()

```js
addArgs(
  newArgs: ComposeFieldConfigArgumentMap<TArgs>
): this
```

### removeArg()

```js
removeArg(
  argNameOrArray: string | string[]
): this
```

### removeOtherArgs()

```js
removeOtherArgs(
  argNameOrArray: string | string[]
): this
```

### reorderArgs()

```js
reorderArgs(
  names: string[]
): this
```

### cloneArg()

```js
cloneArg(
  argName: string,
  newTypeName: string
): this
```

### isRequired()

```js
isRequired(
  argName: string
): boolean
```

### makeRequired()

```js
makeRequired(
  argNameOrArray: string | string[]
): this
```

### makeOptional()

```js
makeOptional(
  argNameOrArray: string | string[]
): this
```

### addFilterArg()

```js
addFilterArg(
  opts: ResolverFilterArgConfig<TSource, TContext, TArgs>
): Resolver<TSource, TContext, TArgs>
```

### addSortArg()

```js
addSortArg(
  opts: ResolverSortArgConfig<TSource, TContext, TArgs>
): Resolver<TSource, TContext, TArgs>
```

## Resolve methods

### getResolve()

```js
getResolve(): ResolverRpCb<TSource, TContext, TArgs>
```

### setResolve()

```js
setResolve(
  resolve: ResolverRpCb<TSource, TContext, TArgs>
): Resolver<TSource, TContext, TArgs>
```

## Wrap methods

### withMiddlewares()

```js
withMiddlewares(
  middlewares: Array<ResolverMiddleware<TSource, TContext, TArgs>>
): Resolver<TSource, TContext, TArgs>
```

You may construct a new resolver with wrapped logic:

```js
const log = [];

const mw1 = async (resolve, source, args, context, info) => {
  log.push('m1.before');
  const res = await resolve(source, args, context, info);
  log.push('m1.after');
  return res;
};

const mw2 = async (resolve, source, args, context, info) => {
  log.push('m2.before');
  const res = await resolve(source, args, context, info);
  log.push('m2.after');
  return res;
};

const newResolver = Resolver.withMiddlewares([mw1, mw2]);
await newResolver.resolve({});

expect(log).toEqual([
  'm1.before',
  'm2.before',
  'call resolve',
  'm2.after',
  'm1.after'
]);
```

### wrap()

```js
wrap<TNewSource = TSource, TNewArgs = TArgs>(
  cb: ResolverWrapCb<TNewSource, TSource, TContext, TNewArgs, TArgs>,
  newResolverOpts: ResolverOpts<TNewSource, TContext, TArgs>
): Resolver<TNewSource, TContext, TNewArgs>
```

### wrapResolve()

```js
wrapResolve<TCSource = TSource, TCArgs = TArgs>(
  cb: ResolverNextRpCb<TCSource, TContext, TCArgs>,
  wrapperName: string
): Resolver<TCSource, TContext, TCArgs>
```

### wrapArgs()

```js
wrapArgs<TCArgs = TArgs>(
  cb: ResolverWrapArgsCb<TCArgs>,
  wrapperName: string
): Resolver<TSource, TContext, TCArgs>
```

### wrapCloneArg()

```js
wrapCloneArg<TCArgs = TArgs>(
  argName: string,
  newTypeName: string
): Resolver<TSource, TContext, TCArgs>
```

### wrapType()

```js
wrapType(
  cb: ResolverWrapTypeCb<TContext>,
  wrapperName: string
): Resolver<TSource, TContext, TArgs>
```

## Misc methods

### getFieldConfig()

```js
getFieldConfig(
  opts: {
      projection?: ProjectionType;
  }
): GraphQLFieldConfig<TSource, TContext, TArgs>
```

### getKind()

```js
getKind(): ResolverKinds | void
```

### setKind()

```js
setKind(
  kind: string
): this
```

### getDescription()

```js
getDescription(): string | null
```

### setDescription()

```js
setDescription(
  description: string | void
): this
```

### get()

```js
get(
  path: string | string[]
): any
```

### clone()

```js
clone<TNewSource = TSource, TNewArgs = TArgs>(
  opts: ResolverOpts<TNewSource, TContext, TNewArgs>
): Resolver<TNewSource, TContext, TNewArgs>
```

## Debug methods

### getNestedName()

```js
getNestedName(): string
```

### toString()

```js
toString(
  colors: boolean
): string
```

### setDisplayName()

```js
setDisplayName(
  name: string
): this
```

### toDebugStructure()

```js
toDebugStructure(
  colors: boolean
): object
```

### debugExecTime()

```js
debugExecTime(): Resolver<TSource, TContext, TArgs>
```

### debugParams()

```js
debugParams(
  filterPaths: (string | string[]) | null,
  opts: ResolveDebugOpts
): Resolver<TSource, TContext, TArgs>
```

### debugPayload()

```js
debugPayload(
  filterPaths: (string | string[]) | null,
  opts: ResolveDebugOpts
): Resolver<TSource, TContext, TArgs>
```

### debug()

```js
debug(
  filterDotPaths: {
      params?: string | string[];
      payload?: string | string[];
  },
  opts: ResolveDebugOpts
): Resolver<TSource, TContext, TArgs>
```

## Internal type definitions

### ResolveParams

```js
export type ResolveParams<TSource, TContext, TArgs = ArgsMap> = {
  source: TSource;
  args: TArgs;
  context: TContext;
  info: GraphQLResolveInfo;
  projection: Partial<ProjectionType>;
  [opt: string]: any;
};
```

### ResolverKinds

```js
export type ResolverKinds = 'query' | 'mutation' | 'subscription';
```

### ResolverFilterArgFn

```js
export type ResolverFilterArgFn<TSource, TContext, TArgs = ArgsMap> = (
  query: any,
  value: any,
  resolveParams: ResolveParams<TSource, TContext, TArgs>,
) => any;
```

### ResolverFilterArgConfig

```js
export type ResolverFilterArgConfig<TSource, TContext, TArgs = ArgsMap> = {
  name: string;
  type: ComposeArgumentType;
  description?: string;
  query?: ResolverFilterArgFn<TSource, TContext, TArgs>;
  filterTypeNameFallback?: string;
  defaultValue?: any;
};
```

### ResolverSortArgFn

```js
export type ResolverSortArgFn<TSource, TContext, TArgs = ArgsMap> = (
  resolveParams: ResolveParams<TSource, TContext, TArgs>,
) => any;
```

### ResolverSortArgConfig

```js
export type ResolverSortArgConfig<TSource, TContext, TArgs = ArgsMap> = {
  name: string;
  sortTypeNameFallback?: string;
  value:
    | { [key: string]: any }
    | ResolverSortArgFn<TSource, TContext, TArgs>
    | string
    | number
    | boolean
    | any[];
  deprecationReason?: string | null;
  description?: string | null;
};
```

### ResolverOpts

```js
export type ResolverOpts<TSource, TContext, TArgs = ArgsMap, TReturn = any> = {
  type?: ComposeOutputType<TReturn, TContext>;
  resolve?: ResolverRpCb<TSource, TContext, TArgs>;
  args?: ComposeFieldConfigArgumentMap<TArgs>;
  name?: string;
  displayName?: string;
  kind?: ResolverKinds;
  description?: string;
  parent?: Resolver<any, TContext, any>;
};
```

### ResolverWrapCb

```js
export type ResolverWrapCb<
  TNewSource,
  TPrevSource,
  TContext,
  TNewArgs = ArgsMap,
  TPrevArgs = ArgsMap
> = (
  newResolver: Resolver<TNewSource, TContext, TNewArgs>,
  prevResolver: Resolver<TPrevSource, TContext, TPrevArgs>,
) => Resolver<TNewSource, TContext, TNewArgs>;
```

### ResolverRpCb

```js
export type ResolverRpCb<TSource, TContext, TArgs = ArgsMap> = (
  resolveParams: ResolveParams<TSource, TContext, TArgs>,
) => Promise<any> | any;
```

### ResolverNextRpCb

```js
export type ResolverNextRpCb<TSource, TContext, TArgs = ArgsMap> = (
  next: ResolverRpCb<TSource, TContext, TArgs>,
) => ResolverRpCb<TSource, TContext, TArgs>;
```

### ResolverWrapArgsCb

```js
export type ResolverWrapArgsCb<TArgs = ArgsMap> = (
  prevArgs: GraphQLFieldConfigArgumentMap,
) => ComposeFieldConfigArgumentMap<TArgs>;
```

### ResolverWrapTypeCb

```js
export type ResolverWrapTypeCb<TContext, TReturn = any> = (
  prevType: GraphQLOutputType,
) => ComposeOutputType<TReturn, TContext>;
```

### ResolveDebugOpts

```js
export type ResolveDebugOpts = {
  showHidden?: boolean;
  depth?: number;
  colors?: boolean;
};
```

### ResolverMiddleware

```js
export type ResolverMiddleware<TSource, TContext, TArgs = ArgsMap> = (
  resolve: (
    source: TSource,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
  ) => any,
  source: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => any;
```
